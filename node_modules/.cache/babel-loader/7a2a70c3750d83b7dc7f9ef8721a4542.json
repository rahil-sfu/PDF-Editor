{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport PDFString from \"../objects/PDFString\";\nimport PDFHexString from \"../objects/PDFHexString\";\n\nvar FileEmbedder =\n/** @class */\nfunction () {\n  function FileEmbedder(fileData, fileName, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.fileData = fileData;\n    this.fileName = fileName;\n    this.options = options;\n  }\n\n  FileEmbedder.for = function (bytes, fileName, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return new FileEmbedder(bytes, fileName, options);\n  };\n\n  FileEmbedder.prototype.embedIntoContext = function (context, ref) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, mimeType, description, creationDate, modificationDate, embeddedFileStream, embeddedFileStreamRef, fileSpecDict;\n\n      return __generator(this, function (_b) {\n        _a = this.options, mimeType = _a.mimeType, description = _a.description, creationDate = _a.creationDate, modificationDate = _a.modificationDate;\n        embeddedFileStream = context.flateStream(this.fileData, {\n          Type: 'EmbeddedFile',\n          Subtype: mimeType !== null && mimeType !== void 0 ? mimeType : undefined,\n          Params: {\n            Size: this.fileData.length,\n            CreationDate: creationDate ? PDFString.fromDate(creationDate) : undefined,\n            ModDate: modificationDate ? PDFString.fromDate(modificationDate) : undefined\n          }\n        });\n        embeddedFileStreamRef = context.register(embeddedFileStream);\n        fileSpecDict = context.obj({\n          Type: 'Filespec',\n          F: PDFString.of(this.fileName),\n          UF: PDFHexString.fromText(this.fileName),\n          EF: {\n            F: embeddedFileStreamRef\n          },\n          Desc: description ? PDFHexString.fromText(description) : undefined\n        });\n\n        if (ref) {\n          context.assign(ref, fileSpecDict);\n          return [2\n          /*return*/\n          , ref];\n        } else {\n          return [2\n          /*return*/\n          , context.register(fileSpecDict)];\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  return FileEmbedder;\n}();\n\nexport default FileEmbedder;","map":{"version":3,"sources":["../../../src/core/embedders/FileEmbedder.ts"],"names":[],"mappings":";AAAA,OAAO,SAAP,MAAgB,sBAAhB;AACA,OAAO,YAAP,MAAmB,yBAAnB;;AAWA,IAAA,YAAA;AAAA;AAAA,YAAA;AAaE,WAAA,YAAA,CACE,QADF,EAEE,QAFF,EAGE,OAHF,EAGmC;AAAjC,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,EAAA;AAAiC;;AAEjC,SAAK,QAAL,GAAgB,QAAhB;AACA,SAAK,QAAL,GAAgB,QAAhB;AACA,SAAK,OAAL,GAAe,OAAf;AACD;;AApBM,EAAA,YAAA,CAAA,GAAA,GAAP,UACE,KADF,EAEE,QAFF,EAGE,OAHF,EAGmC;AAAjC,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,EAAA;AAAiC;;AAEjC,WAAO,IAAI,YAAJ,CAAiB,KAAjB,EAAwB,QAAxB,EAAkC,OAAlC,CAAP;AACD,GANM;;AAsBD,EAAA,YAAA,CAAA,SAAA,CAAA,gBAAA,GAAN,UAAuB,OAAvB,EAA4C,GAA5C,EAAwD;;;;;AAChD,QAAA,EAAA,GAKF,KAAK,OALH,EACJ,QAAQ,GAAA,EAAA,CAAA,QADJ,EAEJ,WAAW,GAAA,EAAA,CAAA,WAFP,EAGJ,YAAY,GAAA,EAAA,CAAA,YAHR,EAIJ,gBAAgB,GAAA,EAAA,CAAA,gBAJZ;AAOA,QAAA,kBAAkB,GAAG,OAAO,CAAC,WAAR,CAAoB,KAAK,QAAzB,EAAmC;AAC5D,UAAA,IAAI,EAAE,cADsD;AAE5D,UAAA,OAAO,EAAE,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAA,QAAA,GAAY,SAFuC;AAG5D,UAAA,MAAM,EAAE;AACN,YAAA,IAAI,EAAE,KAAK,QAAL,CAAc,MADd;AAEN,YAAA,YAAY,EAAE,YAAY,GACtB,SAAS,CAAC,QAAV,CAAmB,YAAnB,CADsB,GAEtB,SAJE;AAKN,YAAA,OAAO,EAAE,gBAAgB,GACrB,SAAS,CAAC,QAAV,CAAmB,gBAAnB,CADqB,GAErB;AAPE;AAHoD,SAAnC,CAArB;AAaA,QAAA,qBAAqB,GAAG,OAAO,CAAC,QAAR,CAAiB,kBAAjB,CAAxB;AAEA,QAAA,YAAY,GAAG,OAAO,CAAC,GAAR,CAAY;AAC/B,UAAA,IAAI,EAAE,UADyB;AAE/B,UAAA,CAAC,EAAE,SAAS,CAAC,EAAV,CAAa,KAAK,QAAlB,CAF4B;AAG/B,UAAA,EAAE,EAAE,YAAY,CAAC,QAAb,CAAsB,KAAK,QAA3B,CAH2B;AAI/B,UAAA,EAAE,EAAE;AAAE,YAAA,CAAC,EAAE;AAAL,WAJ2B;AAK/B,UAAA,IAAI,EAAE,WAAW,GAAG,YAAY,CAAC,QAAb,CAAsB,WAAtB,CAAH,GAAwC;AAL1B,SAAZ,CAAf;;AAQN,YAAI,GAAJ,EAAS;AACP,UAAA,OAAO,CAAC,MAAR,CAAe,GAAf,EAAoB,YAApB;AACA,iBAAA,CAAA;AAAA;AAAA,YAAO,GAAP,CAAA;AACD,SAHD,MAGO;AACL,iBAAA,CAAA;AAAA;AAAA,YAAO,OAAO,CAAC,QAAR,CAAiB,YAAjB,CAAP,CAAA;AACD;;;;;;;AACF,GArCK;;AAsCR,SAAA,YAAA;AAAC,CA7DD,EAAA;;AA+DA,eAAe,YAAf","sourceRoot":"","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\nimport PDFString from \"../objects/PDFString\";\nimport PDFHexString from \"../objects/PDFHexString\";\nvar FileEmbedder = /** @class */ (function () {\n    function FileEmbedder(fileData, fileName, options) {\n        if (options === void 0) { options = {}; }\n        this.fileData = fileData;\n        this.fileName = fileName;\n        this.options = options;\n    }\n    FileEmbedder.for = function (bytes, fileName, options) {\n        if (options === void 0) { options = {}; }\n        return new FileEmbedder(bytes, fileName, options);\n    };\n    FileEmbedder.prototype.embedIntoContext = function (context, ref) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, mimeType, description, creationDate, modificationDate, embeddedFileStream, embeddedFileStreamRef, fileSpecDict;\n            return __generator(this, function (_b) {\n                _a = this.options, mimeType = _a.mimeType, description = _a.description, creationDate = _a.creationDate, modificationDate = _a.modificationDate;\n                embeddedFileStream = context.flateStream(this.fileData, {\n                    Type: 'EmbeddedFile',\n                    Subtype: mimeType !== null && mimeType !== void 0 ? mimeType : undefined,\n                    Params: {\n                        Size: this.fileData.length,\n                        CreationDate: creationDate\n                            ? PDFString.fromDate(creationDate)\n                            : undefined,\n                        ModDate: modificationDate\n                            ? PDFString.fromDate(modificationDate)\n                            : undefined,\n                    },\n                });\n                embeddedFileStreamRef = context.register(embeddedFileStream);\n                fileSpecDict = context.obj({\n                    Type: 'Filespec',\n                    F: PDFString.of(this.fileName),\n                    UF: PDFHexString.fromText(this.fileName),\n                    EF: { F: embeddedFileStreamRef },\n                    Desc: description ? PDFHexString.fromText(description) : undefined,\n                });\n                if (ref) {\n                    context.assign(ref, fileSpecDict);\n                    return [2 /*return*/, ref];\n                }\n                else {\n                    return [2 /*return*/, context.register(fileSpecDict)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    return FileEmbedder;\n}());\nexport default FileEmbedder;\n//# sourceMappingURL=FileEmbedder.js.map"]},"metadata":{},"sourceType":"module"}