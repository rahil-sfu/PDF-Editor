{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\n\nvar PDFCatalog =\n/** @class */\nfunction (_super) {\n  __extends(PDFCatalog, _super);\n\n  function PDFCatalog() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PDFCatalog.prototype.Pages = function () {\n    return this.lookup(PDFName.of('Pages'), PDFDict);\n  };\n  /**\n   * Inserts the given ref as a leaf node of this catalog's page tree at the\n   * specified index (zero-based). Also increments the `Count` of each node in\n   * the page tree hierarchy to accomodate the new page.\n   *\n   * Returns the ref of the PDFPageTree node into which `leafRef` was inserted.\n   */\n\n\n  PDFCatalog.prototype.insertLeafNode = function (leafRef, index) {\n    var pagesRef = this.get(PDFName.of('Pages'));\n    var maybeParentRef = this.Pages().insertLeafNode(leafRef, index);\n    return maybeParentRef || pagesRef;\n  };\n\n  PDFCatalog.prototype.removeLeafNode = function (index) {\n    this.Pages().removeLeafNode(index);\n  };\n\n  PDFCatalog.withContextAndPages = function (context, pages) {\n    var dict = new Map();\n    dict.set(PDFName.of('Type'), PDFName.of('Catalog'));\n    dict.set(PDFName.of('Pages'), pages);\n    return new PDFCatalog(dict, context);\n  };\n\n  PDFCatalog.fromMapWithContext = function (map, context) {\n    return new PDFCatalog(map, context);\n  };\n\n  return PDFCatalog;\n}(PDFDict);\n\nexport default PDFCatalog;","map":{"version":3,"sources":["../../../src/core/structures/PDFCatalog.ts"],"names":[],"mappings":";AAAA,OAAO,OAAP,MAA2B,oBAA3B;AACA,OAAO,OAAP,MAAc,oBAAd;;AAKA,IAAA,UAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAyB,EAAA,SAAA,CAAA,UAAA,EAAA,MAAA,CAAA;;AAAzB,WAAA,UAAA,GAAA;;AAkCC;;AApBC,EAAA,UAAA,CAAA,SAAA,CAAA,KAAA,GAAA,YAAA;AACE,WAAO,KAAK,MAAL,CAAY,OAAO,CAAC,EAAR,CAAW,OAAX,CAAZ,EAAiC,OAAjC,CAAP;AACD,GAFD;AAIA;;;;;;;;;AAOA,EAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,OAAf,EAAgC,KAAhC,EAA6C;AAC3C,QAAM,QAAQ,GAAG,KAAK,GAAL,CAAS,OAAO,CAAC,EAAR,CAAW,OAAX,CAAT,CAAjB;AACA,QAAM,cAAc,GAAG,KAAK,KAAL,GAAa,cAAb,CAA4B,OAA5B,EAAqC,KAArC,CAAvB;AACA,WAAO,cAAc,IAAI,QAAzB;AACD,GAJD;;AAMA,EAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,KAAf,EAA4B;AAC1B,SAAK,KAAL,GAAa,cAAb,CAA4B,KAA5B;AACD,GAFD;;AA9BO,EAAA,UAAA,CAAA,mBAAA,GAAsB,UAC3B,OAD2B,EAE3B,KAF2B,EAEA;AAE3B,QAAM,IAAI,GAAG,IAAI,GAAJ,EAAb;AACA,IAAA,IAAI,CAAC,GAAL,CAAS,OAAO,CAAC,EAAR,CAAW,MAAX,CAAT,EAA6B,OAAO,CAAC,EAAR,CAAW,SAAX,CAA7B;AACA,IAAA,IAAI,CAAC,GAAL,CAAS,OAAO,CAAC,EAAR,CAAW,OAAX,CAAT,EAA8B,KAA9B;AACA,WAAO,IAAI,UAAJ,CAAe,IAAf,EAAqB,OAArB,CAAP;AACD,GARM;;AAUA,EAAA,UAAA,CAAA,kBAAA,GAAqB,UAAC,GAAD,EAAe,OAAf,EAAkC;AAC5D,WAAA,IAAI,UAAJ,CAAe,GAAf,EAAoB,OAApB,CAAA;AAA4B,GADvB;;AAuBT,SAAA,UAAA;AAAC,CAlCD,CAAyB,OAAzB,CAAA;;AAoCA,eAAe,UAAf","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nvar PDFCatalog = /** @class */ (function (_super) {\n    __extends(PDFCatalog, _super);\n    function PDFCatalog() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PDFCatalog.prototype.Pages = function () {\n        return this.lookup(PDFName.of('Pages'), PDFDict);\n    };\n    /**\n     * Inserts the given ref as a leaf node of this catalog's page tree at the\n     * specified index (zero-based). Also increments the `Count` of each node in\n     * the page tree hierarchy to accomodate the new page.\n     *\n     * Returns the ref of the PDFPageTree node into which `leafRef` was inserted.\n     */\n    PDFCatalog.prototype.insertLeafNode = function (leafRef, index) {\n        var pagesRef = this.get(PDFName.of('Pages'));\n        var maybeParentRef = this.Pages().insertLeafNode(leafRef, index);\n        return maybeParentRef || pagesRef;\n    };\n    PDFCatalog.prototype.removeLeafNode = function (index) {\n        this.Pages().removeLeafNode(index);\n    };\n    PDFCatalog.withContextAndPages = function (context, pages) {\n        var dict = new Map();\n        dict.set(PDFName.of('Type'), PDFName.of('Catalog'));\n        dict.set(PDFName.of('Pages'), pages);\n        return new PDFCatalog(dict, context);\n    };\n    PDFCatalog.fromMapWithContext = function (map, context) {\n        return new PDFCatalog(map, context);\n    };\n    return PDFCatalog;\n}(PDFDict));\nexport default PDFCatalog;\n//# sourceMappingURL=PDFCatalog.js.map"]},"metadata":{},"sourceType":"module"}